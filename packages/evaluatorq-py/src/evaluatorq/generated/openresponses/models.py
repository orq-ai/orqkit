# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/openresponses/openresponses/main/public/openapi/openapi.json
#   timestamp: 2026-01-22T16:14:56+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, Literal

from pydantic import BaseModel, Field, RootModel


class Type(Enum):
    item_reference = 'item_reference'


class ItemReferenceParam(BaseModel):
    type: Literal['item_reference'] | None
    id: Annotated[str, Field(description='The ID of the item to reference.')]


class Type1(Enum):
    summary_text = 'summary_text'


class ReasoningSummaryContentParam(BaseModel):
    type: Annotated[
        Type1, Field(description='The content type. Always `summary_text`.')
    ]
    text: Annotated[
        str, Field(description='The reasoning summary text.', max_length=10485760)
    ]


class Type2(Enum):
    reasoning = 'reasoning'


class ReasoningItemParam(BaseModel):
    id: str | None = None
    type: Annotated[
        Literal['reasoning'], Field(description='The item type. Always `reasoning`.')
    ]
    summary: Annotated[
        list[ReasoningSummaryContentParam],
        Field(description='Reasoning summary content associated with this item.'),
    ]
    content: None = None
    encrypted_content: str | None = None


class Type3(Enum):
    input_text = 'input_text'


class InputTextContentParam(BaseModel):
    type: Annotated[
        Literal['input_text'],
        Field(description='The type of the input item. Always `input_text`.'),
    ]
    text: Annotated[
        str, Field(description='The text input to the model.', max_length=10485760)
    ]


class DetailEnum(Enum):
    low = 'low'
    high = 'high'
    auto = 'auto'


class Type4(Enum):
    input_image = 'input_image'


class ImageUrl(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL.',
            max_length=20971520,
        ),
    ]


class Type5(Enum):
    input_file = 'input_file'


class FileData(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='The base64-encoded data of the file to be sent to the model.',
            max_length=33554432,
        ),
    ]


class InputFileContentParam(BaseModel):
    type: Annotated[
        Literal['input_file'],
        Field(description='The type of the input item. Always `input_file`.'),
    ]
    filename: str | None = None
    file_data: FileData | None = None
    file_url: str | None = None


class Type6(Enum):
    message = 'message'


class Role(Enum):
    user = 'user'


class Content1(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='The message content, as a single string.', max_length=10485760
        ),
    ]


class Role1(Enum):
    system = 'system'


class Content2(RootModel[InputTextContentParam]):
    root: Annotated[InputTextContentParam, Field(discriminator='type')]


class Content3(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='The message content, as a single string.', max_length=10485760
        ),
    ]


class SystemMessageItemParam(BaseModel):
    id: str | None = None
    type: Annotated[
        Literal['message'], Field(description='The item type. Always `message`.')
    ]
    role: Annotated[Role1, Field(description='The message role. Always `system`.')]
    content: Annotated[
        list[Content2] | Content3,
        Field(description='The message content, as an array of content parts.'),
    ]
    status: str | None = None


class Role2(Enum):
    developer = 'developer'


class Content4(RootModel[InputTextContentParam]):
    root: Annotated[InputTextContentParam, Field(discriminator='type')]


class Content5(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='The message content, as a single string.', max_length=10485760
        ),
    ]


class DeveloperMessageItemParam(BaseModel):
    id: str | None = None
    type: Annotated[
        Literal['message'], Field(description='The item type. Always `message`.')
    ]
    role: Annotated[Role2, Field(description='The message role. Always `developer`.')]
    content: Annotated[
        list[Content4] | Content5,
        Field(description='The message content, as an array of content parts.'),
    ]
    status: str | None = None


class Type9(Enum):
    url_citation = 'url_citation'


class UrlCitationParam(BaseModel):
    type: Annotated[
        Type9, Field(description='The citation type. Always `url_citation`.')
    ]
    start_index: Annotated[
        int,
        Field(
            description='The index of the first character of the citation in the message.',
            ge=0,
        ),
    ]
    end_index: Annotated[
        int,
        Field(
            description='The index of the last character of the citation in the message.',
            ge=0,
        ),
    ]
    url: Annotated[str, Field(description='The URL of the cited resource.')]
    title: Annotated[str, Field(description='The title of the cited resource.')]


class Type10(Enum):
    output_text = 'output_text'


class OutputTextContentParam(BaseModel):
    type: Annotated[
        Literal['output_text'],
        Field(description='The content type. Always `output_text`.'),
    ]
    text: Annotated[str, Field(description='The text content.', max_length=10485760)]
    annotations: Annotated[
        list[UrlCitationParam] | None,
        Field(description='Citations associated with the text content.'),
    ] = None


class Type11(Enum):
    refusal = 'refusal'


class RefusalContentParam(BaseModel):
    type: Annotated[
        Literal['refusal'], Field(description='The content type. Always `refusal`.')
    ]
    refusal: Annotated[str, Field(description='The refusal text.', max_length=10485760)]


class Type12(Enum):
    message = 'message'


class Role3(Enum):
    assistant = 'assistant'


class Content6(RootModel[OutputTextContentParam | RefusalContentParam]):
    root: Annotated[
        OutputTextContentParam | RefusalContentParam,
        Field(
            description='A piece of assistant message content, such as text or a refusal.',
            discriminator='type',
        ),
    ]


class Content7(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='The message content, as a single string.', max_length=10485760
        ),
    ]


class AssistantMessageItemParam(BaseModel):
    id: str | None = None
    type: Annotated[
        Literal['message'], Field(description='The item type. Always `message`.')
    ]
    role: Annotated[
        Role3, Field(description='The role of the message author. Always `assistant`.')
    ]
    content: Annotated[
        list[Content6] | Content7,
        Field(description='The message content, as an array of content parts.'),
    ]
    status: str | None = None


class FunctionCallItemStatus(Enum):
    in_progress = 'in_progress'
    completed = 'completed'
    incomplete = 'incomplete'


class Type13(Enum):
    function_call = 'function_call'


class Type14(Enum):
    function_call_output = 'function_call_output'


class Output(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='A JSON string of the output of the function tool call.',
            max_length=10485760,
        ),
    ]


class IncludeEnum(Enum):
    reasoning_encrypted_content = 'reasoning.encrypted_content'
    message_output_text_logprobs = 'message.output_text.logprobs'


class EmptyModelParam(BaseModel):
    pass


class Type15(Enum):
    function = 'function'


class FunctionToolParam(BaseModel):
    name: Annotated[str, Field(max_length=64, min_length=1, pattern='^[a-zA-Z0-9_-]+$')]
    description: str | None = None
    parameters: EmptyModelParam | None = None
    strict: bool | None = None
    type: Type15


class ResponsesToolParam(RootModel[FunctionToolParam]):
    root: Annotated[FunctionToolParam, Field(discriminator='type')]


class SpecificFunctionParam(BaseModel):
    type: Annotated[Type15, Field(description='The tool to call. Always `function`.')]
    name: Annotated[str, Field(description='The name of the function tool to call.')]


class SpecificToolChoiceParam(RootModel[SpecificFunctionParam]):
    root: SpecificFunctionParam


class ToolChoiceValueEnum(Enum):
    none = 'none'
    auto = 'auto'
    required = 'required'


class Type17(Enum):
    allowed_tools = 'allowed_tools'


class AllowedToolsParam(BaseModel):
    type: Annotated[
        Type17, Field(description='The tool choice type. Always `allowed_tools`.')
    ]
    tools: Annotated[
        list[SpecificToolChoiceParam],
        Field(
            description='The list of tools that are permitted for this request.',
            max_length=128,
            min_length=1,
        ),
    ]
    mode: ToolChoiceValueEnum | None = None


class ToolChoiceParam(
    RootModel[SpecificToolChoiceParam | ToolChoiceValueEnum | AllowedToolsParam]
):
    root: Annotated[
        SpecificToolChoiceParam | ToolChoiceValueEnum | AllowedToolsParam,
        Field(description='Controls which tool the model should use, if any.'),
    ]


class MetadataParam(RootModel[dict[str, str]]):
    root: Annotated[dict[str, str], Field(max_length=512)]


class VerbosityEnum(Enum):
    low = 'low'
    medium = 'medium'
    high = 'high'


class StreamOptionsParam(BaseModel):
    include_obfuscation: Annotated[
        bool | None,
        Field(
            description='Whether to obfuscate sensitive information in streamed output. Defaults to `true`.'
        ),
    ] = None


class ReasoningEffortEnum(Enum):
    none = 'none'
    low = 'low'
    medium = 'medium'
    high = 'high'
    xhigh = 'xhigh'


class ReasoningSummaryEnum(Enum):
    concise = 'concise'
    detailed = 'detailed'
    auto = 'auto'


class ReasoningParam(BaseModel):
    effort: ReasoningEffortEnum | None = None
    summary: ReasoningSummaryEnum | None = None


class TruncationEnum(Enum):
    auto = 'auto'
    disabled = 'disabled'


class ServiceTierEnum(Enum):
    auto = 'auto'
    default = 'default'
    flex = 'flex'
    priority = 'priority'


class Input(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='Context to provide to the model for the scope of this request. May either be a string or an array of input items. If a string is provided, it is interpreted as a user message.',
            max_length=10485760,
        ),
    ]


class ToolChoice1(BaseModel):
    pass


class ToolChoice2(ToolChoice1):
    pass


class ToolChoice3(Enum):
    none = 'none'
    auto = 'auto'
    required = 'required'


class ToolChoice4(AllowedToolsParam, ToolChoice1):
    pass


class ToolChoice(RootModel[ToolChoice2 | ToolChoice3 | ToolChoice4]):
    root: ToolChoice2 | ToolChoice3 | ToolChoice4


class MaxOutputTokens(RootModel[int]):
    root: Annotated[
        int,
        Field(
            description='The maximum number of tokens the model may generate for this response.',
            ge=16,
        ),
    ]


class MaxToolCalls(RootModel[int]):
    root: Annotated[
        int,
        Field(
            description='The maximum number of tool calls the model may make while generating the response.',
            ge=1,
        ),
    ]


class SafetyIdentifier(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='A stable identifier used for safety monitoring and abuse detection.',
            max_length=64,
        ),
    ]


class PromptCacheKey(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='A key to use when reading from or writing to the prompt cache.',
            max_length=64,
        ),
    ]


class TopLogprobs(RootModel[int]):
    root: Annotated[
        int,
        Field(
            description='The number of most likely tokens to return at each position, along with their log probabilities.',
            ge=0,
            le=20,
        ),
    ]


class IncompleteDetails(BaseModel):
    reason: Annotated[
        str, Field(description='The reason the response could not be completed.')
    ]


class MessageRole(Enum):
    user = 'user'
    assistant = 'assistant'
    system = 'system'
    developer = 'developer'


class Type18(Enum):
    input_text = 'input_text'


class InputTextContent(BaseModel):
    type: Annotated[
        Literal['input_text'],
        Field(description='The type of the input item. Always `input_text`.'),
    ]
    text: Annotated[str, Field(description='The text input to the model.')]


class Type19(Enum):
    url_citation = 'url_citation'


class UrlCitationBody(BaseModel):
    type: Annotated[
        Type19,
        Field(description='The type of the URL citation. Always `url_citation`.'),
    ]
    url: Annotated[str, Field(description='The URL of the web resource.')]
    start_index: Annotated[
        int,
        Field(
            description='The index of the first character of the URL citation in the message.'
        ),
    ]
    end_index: Annotated[
        int,
        Field(
            description='The index of the last character of the URL citation in the message.'
        ),
    ]
    title: Annotated[str, Field(description='The title of the web resource.')]


class Annotation(RootModel[UrlCitationBody]):
    root: Annotated[
        UrlCitationBody,
        Field(
            description='An annotation that applies to a span of output text.',
            discriminator='type',
        ),
    ]


class TopLogProb(BaseModel):
    token: str
    logprob: float
    bytes: list[int]


class LogProb(BaseModel):
    token: str
    logprob: float
    bytes: list[int]
    top_logprobs: list[TopLogProb]


class Type20(Enum):
    output_text = 'output_text'


class OutputTextContent(BaseModel):
    type: Annotated[
        Literal['output_text'],
        Field(description='The type of the output text. Always `output_text`.'),
    ]
    text: Annotated[str, Field(description='The text output from the model.')]
    annotations: Annotated[
        list[Annotation], Field(description='The annotations of the text output.')
    ]
    logprobs: list[LogProb]


class Type21(Enum):
    text = 'text'


class TextContent(BaseModel):
    type: Literal['text']
    text: str


class Type22(Enum):
    summary_text = 'summary_text'


class SummaryTextContent(BaseModel):
    type: Annotated[
        Literal['summary_text'],
        Field(description='The type of the object. Always `summary_text`.'),
    ]
    text: Annotated[
        str,
        Field(description='A summary of the reasoning output from the model so far.'),
    ]


class Type23(Enum):
    reasoning_text = 'reasoning_text'


class ReasoningTextContent(BaseModel):
    type: Annotated[
        Literal['reasoning_text'],
        Field(description='The type of the reasoning text. Always `reasoning_text`.'),
    ]
    text: Annotated[str, Field(description='The reasoning text from the model.')]


class Type24(Enum):
    refusal = 'refusal'


class RefusalContent(BaseModel):
    type: Annotated[
        Literal['refusal'],
        Field(description='The type of the refusal. Always `refusal`.'),
    ]
    refusal: Annotated[
        str, Field(description='The refusal explanation from the model.')
    ]


class ImageDetail(Enum):
    low = 'low'
    high = 'high'
    auto = 'auto'


class Type25(Enum):
    input_image = 'input_image'


class InputImageContent(BaseModel):
    type: Annotated[
        Literal['input_image'],
        Field(description='The type of the input item. Always `input_image`.'),
    ]
    image_url: str | None
    detail: ImageDetail


class Type26(Enum):
    input_file = 'input_file'


class InputFileContent(BaseModel):
    type: Annotated[
        Literal['input_file'],
        Field(description='The type of the input item. Always `input_file`.'),
    ]
    filename: Annotated[
        str | None, Field(description='The name of the file to be sent to the model.')
    ] = None
    file_url: Annotated[
        str | None, Field(description='The URL of the file to be sent to the model.')
    ] = None


class MessageStatus(Enum):
    in_progress = 'in_progress'
    completed = 'completed'
    incomplete = 'incomplete'


class Type27(Enum):
    message = 'message'


class FunctionCallStatus(Enum):
    in_progress = 'in_progress'
    completed = 'completed'
    incomplete = 'incomplete'


class Type28(Enum):
    function_call = 'function_call'


class FunctionCall(BaseModel):
    type: Annotated[
        Literal['function_call'],
        Field(description='The type of the item. Always `function_call`.'),
    ]
    id: Annotated[str, Field(description='The unique ID of the function call item.')]
    call_id: Annotated[
        str,
        Field(
            description='The unique ID of the function tool call that was generated.'
        ),
    ]
    name: Annotated[str, Field(description='The name of the function that was called.')]
    arguments: Annotated[
        str, Field(description='The arguments JSON string that was generated.')
    ]
    status: FunctionCallStatus


class FunctionCallOutputStatusEnum(Enum):
    in_progress = 'in_progress'
    completed = 'completed'
    incomplete = 'incomplete'


class Type29(Enum):
    function_call_output = 'function_call_output'


class Output2(RootModel[InputTextContent | InputImageContent | InputFileContent]):
    root: Annotated[
        InputTextContent | InputImageContent | InputFileContent,
        Field(
            description='A content part that makes up an input or output item.',
            discriminator='type',
        ),
    ]


class FunctionCallOutput(BaseModel):
    type: Annotated[
        Literal['function_call_output'],
        Field(
            description='The type of the function tool call output. Always `function_call_output`.'
        ),
    ]
    id: Annotated[
        str,
        Field(
            description='The unique ID of the function tool call output. Populated when this item is returned via API.'
        ),
    ]
    call_id: Annotated[
        str,
        Field(
            description='The unique ID of the function tool call generated by the model.'
        ),
    ]
    output: str | list[Output2]
    status: FunctionCallOutputStatusEnum


class Type30(Enum):
    reasoning = 'reasoning'


class Content9(
    RootModel[
        InputTextContent
        | OutputTextContent
        | TextContent
        | SummaryTextContent
        | ReasoningTextContent
        | RefusalContent
        | InputImageContent
        | InputFileContent
    ]
):
    root: Annotated[
        InputTextContent
        | OutputTextContent
        | TextContent
        | SummaryTextContent
        | ReasoningTextContent
        | RefusalContent
        | InputImageContent
        | InputFileContent,
        Field(
            description='A content part that makes up an input or output item.',
            discriminator='type',
        ),
    ]


class Summary(
    RootModel[
        InputTextContent
        | OutputTextContent
        | TextContent
        | SummaryTextContent
        | ReasoningTextContent
        | RefusalContent
        | InputImageContent
        | InputFileContent
    ]
):
    root: Annotated[
        InputTextContent
        | OutputTextContent
        | TextContent
        | SummaryTextContent
        | ReasoningTextContent
        | RefusalContent
        | InputImageContent
        | InputFileContent,
        Field(
            description='A content part that makes up an input or output item.',
            discriminator='type',
        ),
    ]


class ReasoningBody(BaseModel):
    type: Annotated[
        Literal['reasoning'],
        Field(description='The type of the item. Always `reasoning`.'),
    ]
    id: Annotated[str, Field(description='The unique ID of the reasoning item.')]
    content: Annotated[
        list[Content9] | None,
        Field(description='The reasoning content that was generated.'),
    ] = None
    summary: Annotated[
        list[Summary],
        Field(description='The reasoning summary content that was generated.'),
    ]
    encrypted_content: Annotated[
        str | None,
        Field(description='The encrypted reasoning content that was generated.'),
    ] = None


class Error(BaseModel):
    code: Annotated[
        str, Field(description='A machine-readable error code that was returned.')
    ]
    message: Annotated[
        str,
        Field(
            description='A human-readable description of the error that was returned.'
        ),
    ]


class Type31(Enum):
    function = 'function'


class FunctionTool(BaseModel):
    type: Annotated[
        Type31, Field(description='The type of the function tool. Always `function`.')
    ]
    name: Annotated[str, Field(description='The name of the function to call.')]
    description: str | None
    parameters: dict[str, Any] | None
    strict: bool | None


class Tool(RootModel[FunctionTool]):
    root: Annotated[
        FunctionTool,
        Field(
            description='A tool that can be used to generate a response.',
            discriminator='type',
        ),
    ]


class FunctionToolChoice(BaseModel):
    type: Type31
    name: str | None = None


class Type33(Enum):
    allowed_tools = 'allowed_tools'


class AllowedToolChoice(BaseModel):
    type: Type33
    tools: list[FunctionToolChoice]
    mode: ToolChoiceValueEnum


class Type34(Enum):
    text = 'text'


class TextResponseFormat(BaseModel):
    type: Type34


class Type35(Enum):
    json_object = 'json_object'


class JsonObjectResponseFormat(BaseModel):
    type: Type35


class Type36(Enum):
    json_schema = 'json_schema'


class JsonSchemaResponseFormat(BaseModel):
    type: Type36
    name: str
    description: str | None
    schema_: Annotated[None, Field(alias='schema')]
    strict: bool


class TextField(BaseModel):
    format: TextResponseFormat | JsonObjectResponseFormat | JsonSchemaResponseFormat
    verbosity: VerbosityEnum | None = None


class Reasoning(BaseModel):
    effort: ReasoningEffortEnum | None
    summary: ReasoningSummaryEnum | None


class InputTokensDetails(BaseModel):
    cached_tokens: Annotated[
        int,
        Field(description='The number of input tokens that were served from cache.'),
    ]


class OutputTokensDetails(BaseModel):
    reasoning_tokens: Annotated[
        int,
        Field(
            description='The number of output tokens that were attributed to reasoning.'
        ),
    ]


class Usage(BaseModel):
    input_tokens: Annotated[
        int,
        Field(
            description='The number of input tokens that were used to generate the response.'
        ),
    ]
    output_tokens: Annotated[
        int,
        Field(
            description='The number of output tokens that were generated by the model.'
        ),
    ]
    total_tokens: Annotated[
        int, Field(description='The total number of tokens that were used.')
    ]
    input_tokens_details: InputTokensDetails
    output_tokens_details: OutputTokensDetails


class Object(Enum):
    response = 'response'


class Type37(Enum):
    response_created = 'response.created'


class Type38(Enum):
    response_queued = 'response.queued'


class Type39(Enum):
    response_in_progress = 'response.in_progress'


class Type40(Enum):
    response_completed = 'response.completed'


class Type41(Enum):
    response_failed = 'response.failed'


class Type42(Enum):
    response_incomplete = 'response.incomplete'


class Type43(Enum):
    response_output_item_added = 'response.output_item.added'


class Item1(BaseModel):
    pass


class Item3(FunctionCall, Item1):
    pass


class Item4(FunctionCallOutput, Item1):
    pass


class Item5(ReasoningBody, Item1):
    pass


class Type44(Enum):
    response_output_item_done = 'response.output_item.done'


class Item61(BaseModel):
    pass


class Item63(FunctionCall, Item61):
    pass


class Item64(FunctionCallOutput, Item61):
    pass


class Item65(ReasoningBody, Item61):
    pass


class Type45(Enum):
    response_reasoning_summary_part_added = 'response.reasoning_summary_part.added'


class ResponseReasoningSummaryPartAddedStreamingEvent(BaseModel):
    type: Annotated[
        Type45,
        Field(
            description='The type of the event, always `response.reasoning_summary_part.added`.'
        ),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    summary_index: Annotated[
        int, Field(description='The index of the summary part that was added.')
    ]
    part: Annotated[
        InputTextContent
        | OutputTextContent
        | TextContent
        | SummaryTextContent
        | ReasoningTextContent
        | RefusalContent
        | InputImageContent
        | InputFileContent,
        Field(
            description='A content part that makes up an input or output item.',
            discriminator='type',
        ),
    ]


class Type46(Enum):
    response_reasoning_summary_part_done = 'response.reasoning_summary_part.done'


class ResponseReasoningSummaryPartDoneStreamingEvent(BaseModel):
    type: Annotated[
        Type46,
        Field(
            description='The type of the event, always `response.reasoning_summary_part.done`.'
        ),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    summary_index: Annotated[
        int, Field(description='The index of the summary part that was completed.')
    ]
    part: Annotated[
        InputTextContent
        | OutputTextContent
        | TextContent
        | SummaryTextContent
        | ReasoningTextContent
        | RefusalContent
        | InputImageContent
        | InputFileContent,
        Field(
            description='A content part that makes up an input or output item.',
            discriminator='type',
        ),
    ]


class Type47(Enum):
    response_content_part_added = 'response.content_part.added'


class ResponseContentPartAddedStreamingEvent(BaseModel):
    type: Annotated[
        Type47,
        Field(
            description='The type of the event, always `response.content_part.added`.'
        ),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    content_index: Annotated[
        int, Field(description='The index of the content part that was added.')
    ]
    part: Annotated[
        InputTextContent
        | OutputTextContent
        | TextContent
        | SummaryTextContent
        | ReasoningTextContent
        | RefusalContent
        | InputImageContent
        | InputFileContent,
        Field(
            description='A content part that makes up an input or output item.',
            discriminator='type',
        ),
    ]


class Type48(Enum):
    response_content_part_done = 'response.content_part.done'


class ResponseContentPartDoneStreamingEvent(BaseModel):
    type: Annotated[
        Type48,
        Field(
            description='The type of the event, always `response.content_part.done`.'
        ),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    content_index: Annotated[
        int, Field(description='The index of the content part that was completed.')
    ]
    part: Annotated[
        InputTextContent
        | OutputTextContent
        | TextContent
        | SummaryTextContent
        | ReasoningTextContent
        | RefusalContent
        | InputImageContent
        | InputFileContent,
        Field(
            description='A content part that makes up an input or output item.',
            discriminator='type',
        ),
    ]


class Type49(Enum):
    response_output_text_delta = 'response.output_text.delta'


class ResponseOutputTextDeltaStreamingEvent(BaseModel):
    type: Annotated[
        Type49,
        Field(
            description='The type of the event, always `response.output_text.delta`.'
        ),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    content_index: Annotated[
        int, Field(description='The index of the content part that was updated.')
    ]
    delta: Annotated[str, Field(description='The text delta that was appended.')]
    logprobs: Annotated[
        list[LogProb],
        Field(
            description='The token log probabilities that were emitted with the delta, if any.'
        ),
    ]
    obfuscation: Annotated[
        str | None,
        Field(
            description='An obfuscation string that was added to pad the event payload.'
        ),
    ] = None


class Type50(Enum):
    response_output_text_done = 'response.output_text.done'


class ResponseOutputTextDoneStreamingEvent(BaseModel):
    type: Annotated[
        Type50,
        Field(description='The type of the event, always `response.output_text.done`.'),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    content_index: Annotated[
        int, Field(description='The index of the content part that was completed.')
    ]
    text: Annotated[str, Field(description='The final text that was emitted.')]
    logprobs: Annotated[
        list[LogProb],
        Field(
            description='The token log probabilities that were emitted with the final text, if any.'
        ),
    ]


class Type51(Enum):
    response_refusal_delta = 'response.refusal.delta'


class ResponseRefusalDeltaStreamingEvent(BaseModel):
    type: Annotated[
        Type51,
        Field(description='The type of the event, always `response.refusal.delta`.'),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    content_index: Annotated[
        int, Field(description='The index of the refusal content that was updated.')
    ]
    delta: Annotated[
        str, Field(description='The refusal text delta that was appended.')
    ]


class Type52(Enum):
    response_refusal_done = 'response.refusal.done'


class ResponseRefusalDoneStreamingEvent(BaseModel):
    type: Annotated[
        Type52,
        Field(description='The type of the event, always `response.refusal.done`.'),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    content_index: Annotated[
        int, Field(description='The index of the refusal content that was completed.')
    ]
    refusal: Annotated[
        str, Field(description='The final refusal text that was emitted.')
    ]


class Type53(Enum):
    response_reasoning_delta = 'response.reasoning.delta'


class ResponseReasoningDeltaStreamingEvent(BaseModel):
    type: Annotated[
        Type53,
        Field(description='The type of the event, always `response.reasoning.delta`.'),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    content_index: Annotated[
        int, Field(description='The index of the reasoning content that was updated.')
    ]
    delta: Annotated[
        str, Field(description='The reasoning text delta that was appended.')
    ]
    obfuscation: Annotated[
        str | None,
        Field(
            description='An obfuscation string that was added to pad the event payload.'
        ),
    ] = None


class Type54(Enum):
    response_reasoning_done = 'response.reasoning.done'


class ResponseReasoningDoneStreamingEvent(BaseModel):
    type: Annotated[
        Type54,
        Field(description='The type of the event, always `response.reasoning.done`.'),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    content_index: Annotated[
        int, Field(description='The index of the reasoning content that was completed.')
    ]
    text: Annotated[
        str, Field(description='The final reasoning text that was emitted.')
    ]


class Type55(Enum):
    response_reasoning_summary_text_delta = 'response.reasoning_summary_text.delta'


class ResponseReasoningSummaryDeltaStreamingEvent(BaseModel):
    type: Annotated[
        Type55,
        Field(
            description='The type of the event, always `response.reasoning_summary.delta`.'
        ),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    summary_index: Annotated[
        int, Field(description='The index of the summary content that was updated.')
    ]
    delta: Annotated[
        str, Field(description='The summary text delta that was appended.')
    ]
    obfuscation: Annotated[
        str | None,
        Field(
            description='An obfuscation string that was added to pad the event payload.'
        ),
    ] = None


class Type56(Enum):
    response_reasoning_summary_text_done = 'response.reasoning_summary_text.done'


class ResponseReasoningSummaryDoneStreamingEvent(BaseModel):
    type: Annotated[
        Type56,
        Field(
            description='The type of the event, always `response.reasoning_summary.done`.'
        ),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    summary_index: Annotated[
        int, Field(description='The index of the summary content that was completed.')
    ]
    text: Annotated[str, Field(description='The final summary text that was emitted.')]


class Type57(Enum):
    response_output_text_annotation_added = 'response.output_text.annotation.added'


class Annotation11(BaseModel):
    pass


class Annotation12(UrlCitationBody, Annotation11):
    pass


class Annotation1(RootModel[Annotation12]):
    root: Annotation12


class ResponseOutputTextAnnotationAddedStreamingEvent(BaseModel):
    type: Annotated[
        Type57,
        Field(
            description='The type of the event, always `response.output_text.annotation.added`.'
        ),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[str, Field(description='The ID of the item that was updated.')]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    content_index: Annotated[
        int, Field(description='The index of the output text content that was updated.')
    ]
    annotation_index: Annotated[
        int, Field(description='The index of the annotation that was added.')
    ]
    annotation: Annotation1 | None


class Type58(Enum):
    response_function_call_arguments_delta = 'response.function_call_arguments.delta'


class ResponseFunctionCallArgumentsDeltaStreamingEvent(BaseModel):
    type: Annotated[
        Type58,
        Field(
            description='The type of the event, always `response.function_call_arguments.delta`.'
        ),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[
        str, Field(description='The ID of the tool call item that was updated.')
    ]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    delta: Annotated[str, Field(description='The arguments delta that was appended.')]
    obfuscation: Annotated[
        str | None,
        Field(
            description='An obfuscation string that was added to pad the event payload.'
        ),
    ] = None


class Type59(Enum):
    response_function_call_arguments_done = 'response.function_call_arguments.done'


class ResponseFunctionCallArgumentsDoneStreamingEvent(BaseModel):
    type: Annotated[
        Type59,
        Field(
            description='The type of the event, always `response.function_call_arguments.done`.'
        ),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    item_id: Annotated[
        str, Field(description='The ID of the tool call item that was updated.')
    ]
    output_index: Annotated[
        int, Field(description='The index of the output item that was updated.')
    ]
    arguments: Annotated[
        str, Field(description='The final arguments string that was emitted.')
    ]


class ErrorPayload(BaseModel):
    type: Annotated[str, Field(description='The error type that was emitted.')]
    code: str | None
    message: Annotated[
        str, Field(description='The human-readable error message that was emitted.')
    ]
    param: str | None
    headers: Annotated[
        dict[str, str] | None,
        Field(
            description='The response headers that were emitted with the error, if any.'
        ),
    ] = None


class Type60(Enum):
    error = 'error'


class ErrorStreamingEvent(BaseModel):
    type: Annotated[Type60, Field(description='The type of the event, always `error`.')]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    error: ErrorPayload


class Type61(Enum):
    input_video = 'input_video'


class InputVideoContent(BaseModel):
    type: Annotated[
        Literal['input_video'],
        Field(description='The type of the input content. Always `input_video`.'),
    ]
    video_url: Annotated[
        str, Field(description='A base64 or remote url that resolves to a video file.')
    ]


class Type62(Enum):
    json_schema = 'json_schema'


class JsonSchemaResponseFormatParam(BaseModel):
    type: Annotated[
        Type62 | None,
        Field(
            description='The type of response format being defined. Always `json_schema`.'
        ),
    ] = None
    description: Annotated[
        str | None,
        Field(
            description='A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n'
        ),
    ] = None
    name: Annotated[
        str | None,
        Field(
            description='The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n'
        ),
    ] = None
    schema_: Annotated[
        dict[str, Any] | None,
        Field(
            alias='schema',
            description='The schema for the response format, described as a JSON Schema object.\n',
            title='JSON schema',
        ),
    ] = None
    strict: bool | None = None


class TextFormatParam(RootModel[TextResponseFormat | JsonSchemaResponseFormatParam]):
    root: TextResponseFormat | JsonSchemaResponseFormatParam


class InputImageContentParamAutoParam(BaseModel):
    type: Annotated[
        Literal['input_image'],
        Field(description='The type of the input item. Always `input_image`.'),
    ]
    image_url: ImageUrl | None = None
    detail: ImageDetail | None = None


class Content(
    RootModel[
        InputTextContentParam | InputImageContentParamAutoParam | InputFileContentParam
    ]
):
    root: Annotated[
        InputTextContentParam | InputImageContentParamAutoParam | InputFileContentParam,
        Field(
            description='A piece of message content, such as text, an image, or a file.',
            discriminator='type',
        ),
    ]


class UserMessageItemParam(BaseModel):
    id: str | None = None
    type: Annotated[
        Literal['message'], Field(description='The item type. Always `message`.')
    ]
    role: Annotated[Role, Field(description='The message role. Always `user`.')]
    content: Annotated[
        list[Content] | Content1,
        Field(description='The message content, as an array of content parts.'),
    ]
    status: str | None = None


class FunctionCallItemParam(BaseModel):
    id: str | None = None
    call_id: Annotated[
        str,
        Field(
            description='The unique ID of the function tool call generated by the model.',
            max_length=64,
            min_length=1,
        ),
    ]
    type: Annotated[
        Literal['function_call'],
        Field(description='The item type. Always `function_call`.'),
    ]
    name: Annotated[
        str,
        Field(
            description='The name of the function to call.',
            max_length=64,
            min_length=1,
            pattern='^[a-zA-Z0-9_-]+$',
        ),
    ]
    arguments: Annotated[
        str, Field(description='The function arguments as a JSON string.')
    ]
    status: FunctionCallStatus | None = None


class Output1(
    RootModel[
        InputTextContentParam
        | InputImageContentParamAutoParam
        | InputFileContentParam
        | InputVideoContent
    ]
):
    root: Annotated[
        InputTextContentParam
        | InputImageContentParamAutoParam
        | InputFileContentParam
        | InputVideoContent,
        Field(
            description='A piece of message content, such as text, an image, or a file.',
            discriminator='type',
        ),
    ]


class FunctionCallOutputItemParam(BaseModel):
    id: str | None = None
    call_id: Annotated[
        str,
        Field(
            description='The unique ID of the function tool call generated by the model.',
            max_length=64,
            min_length=1,
        ),
    ]
    type: Annotated[
        Literal['function_call_output'],
        Field(
            description='The type of the function tool call output. Always `function_call_output`.'
        ),
    ]
    output: Annotated[
        Output | list[Output1],
        Field(description='Text, image, or file output of the function tool call.'),
    ]
    status: FunctionCallStatus | None = None


class ItemParam(
    RootModel[
        ItemReferenceParam
        | ReasoningItemParam
        | UserMessageItemParam
        | SystemMessageItemParam
        | DeveloperMessageItemParam
        | AssistantMessageItemParam
        | FunctionCallItemParam
        | FunctionCallOutputItemParam
    ]
):
    root: Annotated[
        ItemReferenceParam
        | ReasoningItemParam
        | UserMessageItemParam
        | SystemMessageItemParam
        | DeveloperMessageItemParam
        | AssistantMessageItemParam
        | FunctionCallItemParam
        | FunctionCallOutputItemParam,
        Field(discriminator='type'),
    ]


class TextParam(BaseModel):
    format: Annotated[
        TextFormatParam | None,
        Field(description='The format configuration for text output.'),
    ] = None
    verbosity: VerbosityEnum | None = None


class CreateResponseBody(BaseModel):
    model: str | None = None
    input: Input | list[ItemParam] | None = None
    previous_response_id: str | None = None
    include: list[IncludeEnum] | None = None
    tools: list[ResponsesToolParam] | None = None
    tool_choice: ToolChoice | None = None
    metadata: MetadataParam | None = None
    text: TextParam | None = None
    temperature: float | None = None
    top_p: float | None = None
    presence_penalty: float | None = None
    frequency_penalty: float | None = None
    parallel_tool_calls: bool | None = None
    stream: Annotated[
        bool | None,
        Field(description='Whether to stream response events as server-sent events.'),
    ] = None
    stream_options: StreamOptionsParam | None = None
    background: Annotated[
        bool | None,
        Field(
            description='Whether to run the request in the background and return immediately.'
        ),
    ] = None
    max_output_tokens: MaxOutputTokens | None = None
    max_tool_calls: MaxToolCalls | None = None
    reasoning: ReasoningParam | None = None
    safety_identifier: SafetyIdentifier | None = None
    prompt_cache_key: PromptCacheKey | None = None
    truncation: TruncationEnum | None = None
    instructions: str | None = None
    store: Annotated[
        bool | None,
        Field(
            description='Whether to store the response so it can be retrieved later.'
        ),
    ] = None
    service_tier: ServiceTierEnum | None = None
    top_logprobs: TopLogprobs | None = None


class Content8(
    RootModel[
        InputTextContent
        | OutputTextContent
        | TextContent
        | SummaryTextContent
        | ReasoningTextContent
        | RefusalContent
        | InputImageContent
        | InputFileContent
        | InputVideoContent
    ]
):
    root: Annotated[
        InputTextContent
        | OutputTextContent
        | TextContent
        | SummaryTextContent
        | ReasoningTextContent
        | RefusalContent
        | InputImageContent
        | InputFileContent
        | InputVideoContent,
        Field(
            description='A content part that makes up an input or output item.',
            discriminator='type',
        ),
    ]


class Message(BaseModel):
    type: Annotated[
        Literal['message'],
        Field(description='The type of the message. Always set to `message`.'),
    ]
    id: Annotated[str, Field(description='The unique ID of the message.')]
    status: MessageStatus
    role: MessageRole
    content: Annotated[list[Content8], Field(description='The content of the message')]


class ItemField(RootModel[Message | FunctionCall | FunctionCallOutput | ReasoningBody]):
    root: Annotated[
        Message | FunctionCall | FunctionCallOutput | ReasoningBody,
        Field(
            description='An item representing a message, tool call, tool output, reasoning, or other response element.',
            discriminator='type',
        ),
    ]


class ResponseResource(BaseModel):
    id: Annotated[
        str, Field(description='The unique ID of the response that was created.')
    ]
    object: Annotated[
        Object, Field(description='The object type, which was always `response`.')
    ]
    created_at: Annotated[
        int,
        Field(
            description='The Unix timestamp (in seconds) for when the response was created.'
        ),
    ]
    completed_at: int | None
    status: Annotated[
        str, Field(description='The status that was set for the response.')
    ]
    incomplete_details: IncompleteDetails | None
    model: Annotated[str, Field(description='The model that generated this response.')]
    previous_response_id: str | None
    instructions: str | None
    output: Annotated[
        list[ItemField],
        Field(description='The output items that were generated by the model.'),
    ]
    error: Error | None
    tools: Annotated[
        list[Tool],
        Field(
            description='The tools that were available to the model during response generation.'
        ),
    ]
    tool_choice: FunctionToolChoice | ToolChoiceValueEnum | AllowedToolChoice
    truncation: TruncationEnum
    parallel_tool_calls: Annotated[
        bool,
        Field(
            description='Whether the model was allowed to call multiple tools in parallel.'
        ),
    ]
    text: TextField
    top_p: Annotated[
        float,
        Field(
            description='The nucleus sampling parameter that was used for this response.'
        ),
    ]
    presence_penalty: Annotated[
        float,
        Field(
            description='The presence penalty that was used to penalize new tokens based on whether they appear in the text so far.'
        ),
    ]
    frequency_penalty: Annotated[
        float,
        Field(
            description='The frequency penalty that was used to penalize new tokens based on their frequency in the text so far.'
        ),
    ]
    top_logprobs: Annotated[
        int,
        Field(
            description='The number of most likely tokens that were returned at each position, along with their log probabilities.'
        ),
    ]
    temperature: Annotated[
        float,
        Field(description='The sampling temperature that was used for this response.'),
    ]
    reasoning: Reasoning | None
    usage: Usage | None
    max_output_tokens: int | None
    max_tool_calls: int | None
    store: Annotated[
        bool,
        Field(
            description='Whether this response was stored so it can be retrieved later.'
        ),
    ]
    background: Annotated[
        bool, Field(description='Whether this request was run in the background.')
    ]
    service_tier: Annotated[
        str, Field(description='The service tier that was used for this response.')
    ]
    metadata: Annotated[
        Any,
        Field(
            description='Developer-defined metadata that was associated with the response.'
        ),
    ]
    safety_identifier: str | None
    prompt_cache_key: str | None


class ResponseCreatedStreamingEvent(BaseModel):
    type: Annotated[
        Type37, Field(description='The type of the event, always `response.created`.')
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    response: ResponseResource


class ResponseQueuedStreamingEvent(BaseModel):
    type: Annotated[
        Type38, Field(description='The type of the event, always `response.queued`.')
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    response: ResponseResource


class ResponseInProgressStreamingEvent(BaseModel):
    type: Annotated[
        Type39,
        Field(description='The type of the event, always `response.in_progress`.'),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    response: ResponseResource


class ResponseCompletedStreamingEvent(BaseModel):
    type: Annotated[
        Type40, Field(description='The type of the event, always `response.completed`.')
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    response: ResponseResource


class ResponseFailedStreamingEvent(BaseModel):
    type: Annotated[
        Type41, Field(description='The type of the event, always `response.failed`.')
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    response: ResponseResource


class ResponseIncompleteStreamingEvent(BaseModel):
    type: Annotated[
        Type42,
        Field(description='The type of the event, always `response.incomplete`.'),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    response: ResponseResource


class Item2(Message, Item1):
    pass


class Item(RootModel[Item2 | Item3 | Item4 | Item5]):
    root: Item2 | Item3 | Item4 | Item5


class ResponseOutputItemAddedStreamingEvent(BaseModel):
    type: Annotated[
        Type43,
        Field(
            description='The type of the event, always `response.output_item.added`.'
        ),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    output_index: Annotated[
        int, Field(description='The index of the output item that was added.')
    ]
    item: Item | None


class Item62(Message, Item61):
    pass


class Item6(RootModel[Item62 | Item63 | Item64 | Item65]):
    root: Item62 | Item63 | Item64 | Item65


class ResponseOutputItemDoneStreamingEvent(BaseModel):
    type: Annotated[
        Type44,
        Field(description='The type of the event, always `response.output_item.done`.'),
    ]
    sequence_number: Annotated[
        int, Field(description='The sequence number of the event that was emitted.')
    ]
    output_index: Annotated[
        int, Field(description='The index of the output item that was completed.')
    ]
    item: Item6 | None
